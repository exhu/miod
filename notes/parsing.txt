First pass:
    - populate symbol table
    - evaluate declaration expressions for consts
    - visit only static_if branch that solves to 'true'

Second pass:
    - refine symbol table
    - evaluate all expressions
    - semantic check

Third pass implementation may vary:
    - generate C/C++ code
    - generate Java code
    - generate docs

-=-=-=-=-
Root scope
    - parent = null
    - symbols:
        - predefined
        - definitions passed via command line args

Units map[full_name, Unit]
    - Unit
        - Scope
            - proc, struct, block scopes...

'import' statement checks Units map and does not reparse already parsed/being
parsed units, adds SymItem with unit name.

-=-=-=-==--
Global scope
    - compiler defined globals
    - -Dmyvar=myvalue defines for static_if -- this feature is not of top
    priority, better to use mypkg::config units with global constants,
    e.g. mypkg/config.miod.template which user copies and modifies.

Other scopes:
- unit
    - static_if
    - proc
        - args
            - static_if
            - with
            - finally
            - for
            - while
            - if

    - class
        - method (see proc)
    - struct
    - enum

Pass 1:
    - build and populate scopes with 'unknown' type for expr types of vars
    - try to evaluate types for expressions
    - global consts must evaluate completely
    - skip handlers for nodes under static_if

Pass 2:
    - evaluate expressions
    - fill in scope types, not known on pass 1
    - skip handlers for nodes under static_if
    - generate code

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

progam = CompilationUnit
    - CompilationUnit
        - filename
        - globalSymTable
        - imports
            - CompilationUnit[]

    - BaseSymTable
        - items
            - SymItem[]
        - parent
            - SymTable

    - GlobalSymTable : BaseSymTable
        - unitName
        - namespace
        - imports
            - globalSymTable[]

    - SymItem
        - location
            - CompilationUnit

    - ProcTypeWithBody
        - finals
        - blocks

Cycles:
    - CompilationUnit -> BaseSymTable->SymItem->SymLocation-><
    - BaseSymTable -> parent -><

==========================

Compiler notes:

- during parsing the main unit dependencies are being parsed as well

Optimization for compiler as a service feature:
- keep parsing trees for imported units
- reuse the trees for subsequent compilation calls

===============================

Program
    - unit search paths
    - compilation units


Compilation unit
    - file
    - symbol table

Symbol table
    - parent
    - map(name, Symbol)

Location
    - compilation unit
    - line, col

Symbol
    - location
    - name
    - kind (alias, value, typedef, struct, array, proc)
    - annotations

Alias extends Symbol
    - symbol

Value extends Symbol
    - type
    - data

Typedef extends Symbol
    - symbol

Struct extends Symbol
    - SymbolTable

Array extends Symbol
    - type
    - size

-=-=-=-=-=-=
Symbol can be
    - Typed:
        - proc
        - var
        - const
        - struct
        - class
        - array
        - typedef
        - alias
        - method

    - Non-typed:
        - unit

Type can be:
    - another Symbol
    - built-in

