unit myprog.hello
import c.stdio

alias log = printf

const
    scrRect: Rect = {x: 0, y:0, w: 640, h: 480}
    # syntax sugar for structs with only two members:
    myMap: array<Pair> = {"aa": "bb", "ww": "cc"}

    mybin = 0b1111_1100_0011
    myhex = 0xFFFF_1234
    mysuperstring = """

#[[

long comments

#]]

## documentation comment

var
    dynAr: dynarray<Pair>
    nw: ref<scrRect>
    arrr: array<int, 3>
    arauto = [1,2,3]

type
    Pair = struct
        k, v: String
    end_struct

    FILE = cstruct
    PFILE = ptr<FILE>

    Updateable = interface
        proc update()
    end_interface

    ## static interface, i.e. compiler will emit error if update() is not
    ## implemented. Structs support inheritence but no virtuals.
    Rect = struct(Updateable)
        x,y,w,h,x2,y2: int
        proc update()
            # local constant
            let a = x+w
            x2 = x+w
            y2 = y+h
        end
    end_struct


    # add static methods to type Rect
    RectPlus = struct_helper(Rect)
        proc add(r: Rect)
            x += r.x
            y += r.y
        end
    end_struct

    MyUnion = union
        dw: uint32
        w1, w2: uint16
    end_union

    sql = annotation
        table: string
    end_annotation

    field = annotation
        name: string
    end_annotation

    @sql{table:"myt"}
    MyCls = class(Cloneable)
        public
        proc assign(o: MyCls)
           a = o.a
           b = o.b
        end


        private
        @field{name:"a"}
        a,
        @field{name:"b"}
        b: int

        parent: weak<MyCls>

        public
        property(pa: int, read: a)
        property(pb: int, write: b, read: b)
        
    end_class

    MyClsHelper = class_helper(MyCls)
        public
        proc add(o: MyCls)
            a += o.a
            b += o.b
        end
    end_class


    Map<K, V> = interface
        proc get(k: K): V
        proc set(k: K, v: V)

    end_interface

    ## system structure
    Class = struct
        ## CRC32 ?
        id: int32 
        size: cardinal
        name: String
        vtbl: pointer

        # initialize vtbl, class pointer etc.
        proc init(o: Object)
        end
    end_struct

    MyColl<K,V> = class(Map, NewInstance, CopyFrom)
    public
        ## default destructor from Object class
        proc finalize(), override
            # some destructor stuff
        end

        ## Obsolete?
        ## NewInstance, return new uninit. instance of this class
        proc new_instance(a: Allocator): Object, override
            return a.new(MyColl)
        end

        ## CopyFrom, copy data from o
        proc copy_from(o: Object), override
           assert(o.instance_of(MyColl)) 
           var src = cast<MyColl>(o)
        end

    private
        keys: dynarray<K>
        values: dynarray<V>

    end_class
        
    MyCollS = MyColl<String, String>

public

@_cattr{cc:"cdecl", header:"<stdio.h>", name:"printf"}
cproc printf(fmt: cstring, args: cvarargs)

proc format(fmt: String, args: array<Object>): String
    for a,i in args do
        

    end_for

    for(a: int = 0, b = 3; a+= b; a != 3)

    end_for
end

proc mod(a: int, var b:int)
    b = a+1
end


proc main()
    printf("Hi! %d\n", [1]);
end
