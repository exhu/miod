type EntryField = interface
    proc name(): string;
    proc fromString(s: string);
    proc toString(): string;
endi


type Entry = interface
    proc fields(): array[EntryField];
endi

type MyValueType = struct
    x, y: int
    sz: uint

    proc mul() =
        sz = x*y
    end
ends

type PMyValue = ptr[MyValueType]

cproc someCProcedure(a, b: cint): cint name("asum");
cproc printf(a: cstring) cvarargs;

type DirEntry = class(Entry)
    id: IDField
    name: TextField
    timestamp: DateTimeField
    w1: weak[Entry]  # just weak reference, is not checked in release build
    w2: weak_watch[Entry] # weak reference, becomes NULL on release

    # TODO think over possible HEAP POOLS for same types
    proc init() =
        # constructor 1
        # allocates an instance from heap
    end

    proc init(id: IDField) =
        # constructor 2
        this.id = id
        # passing "this" var as argument is not allowed here
    end

    proc done() =
        # destructor
    end

    proc id(): IDField final inline =
        return this.id
    end

    proc fields(): array[EntryField] override final =
       return [id.addr, name.addr, timestamp.addr] 
    end

    protected

    public

    private

        
endc


if a > b then b = a endif
if c < b then c = b else c = b+1 endif
if d != c then d = c elseif d > c then d = c+1 endif


dyn_package.def:
    org.palitsa.*
    org.dum.MyModule

