TODO:

- expression evaluation = node(type, value?)
    - fix RuntimeValue expressions, it throws OperationNotSupported even if types
    do support that operation but the value is of RuntimeValue
    - if values then check compatibility

- first visitor declares vars, evals expressions,
    adds imports, triggers imported units parsing,
    marks nodes requiring second pass
- second visitor
    processes nodes marked: declares vars, evals expressions

+ finish UnitParser.java
- class is the only reference type, arrays are copied, allocated from class
    storage, or global storage
- dynamic arrays are allocated via C implementation.
- review grammar
- var a : type -> add symbol table item with resolved 'type' (i.e. bypass alias)

Version 1 features

- constants with literals
- procs with local vars
- visibility levels (public, protected, private)
- structs
- opaque
- unions via opaque
- global vars
- cprocs (@_cattr)
- static packages
- nstring, nwstring

Version 2

- classes
- interfaces
- int32 analogue to System.identityHashCode(Object)
- base_class for extendable classes, deprecate "final" keyword,
include "virtual" keyword
- interfaces
- cmake integration

Version 3

- reference-counted classes with weak pointers and references
- interfaces

Version 4

- dynamic arrays
- Base object class, base interface (interface -> Object instance)
- String class

Version 5

- Generics (auto type-cast) support

Version 6

- generic units support (templates-like engine)

Version 7

- RTL

Version 8

- dynamic packages (sets)


